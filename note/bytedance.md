
### 0x00 http与https的区别，并具体说明https的原理，如何保证幂等性
#### http与https的区别
- http无加密，https有ssl/tls加密
- 默认端口不一样
- https需要申请ca证书
- https需要加密解密，握手过程复杂，因此页面打开速度稍慢
#### https优化
- hsts重定向：将http自动转换为https，减少301/302重定向
- tls握手优化：在握手完成前就提前发送数据
- 会话标识符：服务端记录下客户端会话标识，减少下次连接时的验证步骤
- 完全前向PFS：更厉害的私钥算法
#### https流程/原理
- 客户端发起请求
- 服务端将包含公钥的证书发给客户端
- 客户端校验证书的有效性，校验通过后，使用证书中的公钥加密一段随机字符串发给服务端
- 服务端使用私钥解析出客户端发来的随机字符串
- 客户端和服务端后续通信都使用客户端生成的那段随机字符串来加密信息

### 0x01 session与cookie，以及项目中怎么用的
- 项目中不涉及页面，所以基本不涉及session与cookie
- session存在服务端，cookie存在客户端
- session可以存登录状态信息，cookie存一下安全性要求不高的信息

### 0x02 输入一个网址到浏览器渲染出页面的过程中有哪些报文，分别涉及哪些协议，协议的主要内容是啥，分别用来做什么的。
- 在浏览器输入url
- DNS解析出IP地址
- 客户端与服务端建立起TCP连接
- 客户端向服务端发送http/https请求
- 服务器响应请求或重定向到其他url
- 客户端收到响应内容，并解析渲染
- 如果响应内容中有其他超链接，重复以上过程

### 0x03 TCP 3次握手 4次挥手 拥塞控制 会出现哪些问题，如果过程中服务器宕机会出现什么问题，怎么去解决。
#### 三次握手过程
- SYN(x) ---->
- <----  ACK(x+1)、SYN(y)
- ACK(y+1) ---->
#### 第三次握手失败时处理方案
- 等待超时
- 超时后，server向client发送RTS报文并进入关闭状态
#### 四次挥手过程
- FIN(x) ---->
- <---- ACK(x+1)
- <---- FIN(y)
- ACK(y+1)---->
#### 为什么需要四次挥手
- 服务端收到FIN后仅表示知道了对方不再发送消息，己方是否关闭需要等待上层决定

### 0x04 同步IO和异步IO， 直接 I/O 和缓冲 I/O 区别
- [ ]  TODO

### 0x05 进程和线程的区别，创建线程和进程的开销指什么，协程
- 进程是系统进行资源分配的基本单位，有独立的内存地址空间
- 线程是cpu调度的基本单位，没有独立的内存地址空间，有独立的栈、局部变量、寄存器
- 一个进程无法直接访问另外一个进程的资源，同一进程内的线程之间可以共享进程的资源
- 进程的创建、切换、通信时开销大，线程的创建、切换、通信开销相对较小
- 进程必须归属于一个线程，不能独立运行；每个进程至少要有一个线程，成为主线程

### 0x06 事务的四个隔离级别
- 读已提交
- 读未提交
- 可重复读
- 串行

### 0x07 InnoDB的索引类型
- B+树

### 0x08 B树和B+树的区别
- B+树所有叶子节点都是连在一起的，便于MySQL的>查询
- B+树内部节点出现过的元素，会在叶子节点再出现一次，B树则不会
- B+树只有叶子节点有指向元素的指针，而B树所有节点都有

### 0x09 堆里面如何控制并发安全
????

### 0x10 死锁及如何避免
#### 定义
- 多个进程因资源竞争而造成的一中互相等待的状态，且在没有外力推进的情况下，这种情况会一直持续。
#### 产生的原因
- 系统资源不足
- 系统资源分配不当
- 请求和释放资源的顺序不当
#### 死锁的四个必要条件
- 互斥条件
- 请求与保持条件
- 不可剥夺条件
- 循环等待条件
#### 死锁的避免与预防
- 进程启动拒绝：如果一个进程的启动请求会导致死锁，则不允许该进程启动
- 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配（`银行家算法`）
- 资源有序分配：对每类资源进行分类编号，按顺序分配释放。
#### 银行家算法
- 当一个进程申请资源时，先试探着分配资源，然后再分析分配后整个系统是否处于安全状态，如果不安全，撤销此次分配。
### 0x11 操作系统当中的进程调度算法。每种算法的优缺点

### 0x12 Python 垃圾回收
- 引用计数
- 标记清除
    - 将所有的对象标为点，将对象之间的引用关系作为边，形成有向图
    - 从根节点开始遍历图，遍历不到的对象会被回收
- 分代回收
    - 降低回收频率
    - 新建的对象为0代，每存活过一次回收代数加一，最高为2代
    - （700，10，10）
    - 分配对象个数与释放的对象个数之间的差值为700时，回收0代
    - 10次0代回收触发一次1代回收，10次1代回收触发一次2代回收

### 0x13 Golang 垃圾回收
- [ ] TODO

### 0x14 chmod 
- r:4  w:2  x:1 

### 0x15 数据库范式
> 数据库设计的规范
- 1NF：每一列都不可再拆分
- 2NF：满足1NF，必须有主键，非主键列必须*完全依赖*于主键，不能*部分依赖*于主键
- 3NF：满足2NF，非主键列必须*直接依赖*于主键，不能通过*传递依赖*
- 1-3NF：每一列都不可拆分，有主键，非主键列必须直接且完全依赖于主键列

### 0x15 MySQL limit优化
- 使用主键或者有索引的列做order by
- 记录上次使用的主键的id，在下次查询时，使用主键where过滤

