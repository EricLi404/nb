
## 0x00 http与https的区别，并具体说明https的原理，如何保证幂等性
### http与https的区别
- http无加密，https有ssl/tls加密
- 默认端口不一样
- https需要申请ca证书
- https需要加密解密，握手过程复杂，因此页面打开速度稍慢
### https优化
- hsts重定向：将http自动转换为https，减少301/302重定向
- tls握手优化：在握手完成前就提前发送数据
- 会话标识符：服务端记录下客户端会话标识，减少下次连接时的验证步骤
- 完全前向PFS：更厉害的私钥算法
### https流程/原理
- 客户端发起请求
- 服务端将包含公钥的证书发给客户端
- 客户端校验证书的有效性，校验通过后，使用证书中的公钥加密一段随机字符串发给服务端
- 服务端使用私钥解析出客户端发来的随机字符串
- 客户端和服务端后续通信都使用客户端生成的那段随机字符串来加密信息

## 0x01 session与cookie，以及项目中怎么用的
- 项目中不涉及页面，所以基本不涉及session与cookie
- session存在服务端，cookie存在客户端
- session可以存登录状态信息，cookie存一下安全性要求不高的信息

## 0x02 输入一个网址到浏览器渲染出页面的过程中有哪些报文，分别涉及哪些协议，协议的主要内容是啥，分别用来做什么的。
- 在浏览器输入url
- DNS解析出IP地址
- 客户端与服务端建立起TCP连接
- 客户端向服务端发送http/https请求
- 服务器响应请求或重定向到其他url
- 客户端收到响应内容，并解析渲染
- 如果响应内容中有其他超链接，重复以上过程

## 0x03 TCP 3次握手 4次挥手 拥塞控制 会出现哪些问题，如果过程中服务器宕机会出现什么问题，怎么去解决。
### 三次握手过程
- SYN(x) ---->
- <----  ACK(x+1)、SYN(y)
- ACK(y+1) ---->
### 第三次握手失败时处理方案
- 等待超时
- 超时后，server向client发送RTS报文并进入关闭状态
### 四次挥手过程
- FIN(x) ---->
- <---- ACK(x+1)
- <---- FIN(y)
- ACK(y+1)---->
### 为什么需要四次挥手
- 服务端收到FIN后仅表示知道了对方不再发送消息，己方是否关闭需要等待上层决定

## 0x04 同步IO和异步IO， 直接 I/O 和缓冲 I/O 区别
- [ ]  TODO

## 0x05 进程和线程的区别，创建线程和进程的开销指什么，协程
- 进程是系统进行资源分配的基本单位，有独立的内存地址空间
- 线程是cpu调度的基本单位，没有独立的内存地址空间，有独立的栈、局部变量、寄存器
- 一个进程无法直接访问另外一个进程的资源，同一进程内的线程之间可以共享进程的资源
- 进程的创建、切换、通信时开销大，线程的创建、切换、通信开销相对较小
- 进程必须归属于一个线程，不能独立运行；每个进程至少要有一个线程，成为主线程

## 0x06 事务的四个隔离级别
- [ ]  TODO

## 0x07 InnoDB的索引类型

## 0x08 B树和B+树的区别

## 0x09 堆里面如何控制并发安全

## 0x10 死锁及如何避免
### 定义
- 多个进程因资源竞争而造成的一中互相等待的状态，且在没有外力推进的情况下，这种情况会一直持续。
### 产生的原因
- 系统资源不足
- 系统资源分配不当
- 请求和释放资源的顺序不当
### 死锁的四个必要条件
- 互斥条件
- 请求与保持条件
- 不可剥夺条件
- 循环等待条件
### 死锁的避免与预防
- 进程启动拒绝：如果一个进程的启动请求会导致死锁，则不允许该进程启动
- 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配（`银行家算法`）
- 资源有序分配：对每类资源进行分类编号，按顺序分配释放。
### 银行家算法
- 当一个进程申请资源时，先试探着分配资源，然后再分析分配后整个系统是否处于安全状态，如果不安全，撤销此次分配。
## 0x11 操作系统当中的进程调度算法。每种算法的优缺点

## 0x12 Python 垃圾回收

## 0x13 Golang 垃圾回收

## 0x14 chmod 
- r:4  w:2  x:1 

## 0x15 数据库范式